#+BEGIN_COMMENT
.. title: OpenSSL Sockets in C++ (part 1)
.. slug: openssl-sockets-in-c++-part-1
.. date: 2014-12-22 16:52:09 UTC-08:00
.. tags: private
.. link: 
.. description: 
.. type: text
#+END_COMMENT


The goal of this tutorial series is to walk through using posix sockets, from the ground up. Projects merely wishing to add networking would probably be best advised to look at already well established abstraction layers like [[http://www.boost.org/doc/libs/1_57_0/doc/html/boost_asio.html][Boost Asio]].

* Initial stub

To start off, we're going to create a basic http request. To keep things simple, for the first iteration, we're going to use a plain TCP blocking socket. First create a cpp file (mine is named sockets\_part1.cpp). First some constants and includes:

#+NAME: sockets_part1.cpp
#+BEGIN_SRC cpp
  #include <iostream>
  #include <string>
  #include <sys/socket.h>
  #include <netdb.h>

  namespace
  {
      const char HOST[] = "fizz.buzz";
      const size_t BUFFER_SIZE = 1024;
  }

  int main(int argc, char** argv)
  {
      return 0;
  }
#+END_SRC

The first step to most network connections is doing a DNS request to convert a hostname like "fizz.buzz" to an ip address like "208.113.196.82". For illustration purposes you could manually do a DNS request from the shell with the following command:
#+BEGIN_SRC sh
  $ dig +short fizz.buzz
  208.113.196.82
#+END_SRC

To make a DNS request we will be using [[https://www.freebsd.org/cgi/man.cgi?query=getaddrinfo&sektion=3][getaddrinfo(3)]] which will set the address of an addrinfo pointer passed into it.

#+BEGIN_SRC cpp
  struct addrinfo* address_info;
  int error = getaddrinfo(HOST, "http", nullptr, &address_info);
  if (error != 0)
  {
      throw std::string("Error getting address info: ") + std::string(gai_strerror(error));
  }
#+END_SRC

The second parameter to getaddrinfo defines the port. This can be a string for a protocol like "http" or "https", or it can be a numeric string like "80" and "443".

The third parameter to getaddrinfo is a set of "hints" indicating what type of connection we're looking to open. The hints param is optional and could just be a nullptr in this case without issue. In our hints we're setting =ai_family= to =PF_UNSPEC= to indicate that we are fine with any protocol. We're also setting =ai_socktype= to =SOCK_STREAM= to indicate that we wish to open a two way byte stream.

The =addrinfo= struct that =address_info= now points to looks like this:
#+BEGIN_SRC text
  addrinfo:
    ai_flags      0
    ai_family     2               # AF_INET
    ai_socktype   1               # SOCK_STREAM
    ai_protocol   6               # IPPROTO_TCP
    ai_addrlen    16              # Length in bytes for the next field (ai_addr)
    ai_addr       sockaddr_in
      sin_family  2               # AF_INET (ipv4)
      sin_port    80              # default http port
      sin_addr    208.113.196.82  # ipv4 address to fizz.buzz
    ai_canonname  <blank>
    ai_next       nullptr         # Forms a linked list
#+END_SRC
