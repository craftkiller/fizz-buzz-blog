#+BEGIN_COMMENT
.. title: OpenSSL Sockets in C++ (part 3)
.. slug: openssl-sockets-in-c++-part-3
.. date: 2014-12-25 19:15:55 UTC-08:00
.. tags: private
.. link: 
.. description: 
.. type: text
#+END_COMMENT


For this post we're going to move all of our code from [[http://fizz.buzz/posts/openssl-sockets-in-c++-part-2.html][part 2]] into its own class to facilitate the SSL transition. This will be the last post before we start using OpenSSL to encrypt the stream. We're going to create two files =ssl_socket.h= and =ssl_socket.cpp=. Since all the socket code was covered in [[http://fizz.buzz/posts/openssl-sockets-in-c++-part-1.html][part 1]] and [[http://fizz.buzz/posts/openssl-sockets-in-c++-part-2.html][part 2]] we're not going to go into too much detail with the code. Instead, we'll cover the structure of the class.

For our socket class error handling we're going to take a deviation from much of the networking functions we've been using. The BSD/posix networking functions traditionally either return an error number or set errno to indicate when theres a problem. Unfortunately, when doing this style of error handling, every call must be followed by a series of if statements for handling errors. This is due to the fact that they're implemented in C which lacked exception support. C++ support [[http://mortoray.com/2013/09/12/the-true-cost-of-zero-cost-exceptions/][zero cost exceptions]] which incur zero run-time cost when an exception has *not* occurred. Since errors should be the exception (hahaha) to the rule, in terms of performance it makes sense to use them rather than rely on branch prediction to reduce the cost of if-statement error handling.

We're going to move most all of the code up to the =send=/=recv= block in a =connect()= function. We don't want this in the constructor to in order to allow for re-connecting the sockets on failure (useful in chat clients). We'll also introduce a =disconnect= function to allow for a socket to be disconnected without requiring the destruction of the object. The copy and assignment ctor will be disabled in order to prevent accidental copying.

We're going to introduce =read= and =write= functions. The =read= function will behave in a non-blocking fashion returning the data and the number of bytes read. The =write= function, however, we will make blocking for simplicity, so we don't have to have either a thread or another callback to constantly push more data in a queue across the socket.
